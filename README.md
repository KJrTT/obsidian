### *ООП
ООП --> парадигма разработки ПО при которой программа представляется как совокупность объектов, взаимодействующих друг с другом.*

Свойства --> поля(атрибуты)
Действия --> методы (функции)

ООП --> Он завязан на действиях. Исходит от объектов(сущностях)

Преимущества:
	- Модульность (код разбит на модули)
	- Масштабируемость 
	- Безопасность 
	- Паттерны (шаблоны проектирования)

Недостатки:
	- Сложность освоения 
	- Снижение производительности  
	- Громоздкость кода
	- Потенциальная избыточность 

Четыре элемента ООП:
	- Объект --> это сущность, представляющая собой комбинацию свойств и методов.
	- Класс --> шаблон для создания объекта
	- Атрибут --> переменные принадлежащие объекту, то есть хранят характеристики объектов.
	- Метод --> функции, которые определяются внутри класса, и работают с его данными
		- Getter/ setter (getter --> для узнавания значений, setter --> для изменения значений)
		- Конструкторы / деструкторы

Область видимости:
	- Public --> Доступно везде
	- Protected --> Доступно только наследникам
	- Private --> Доступно только для этого класса

Четыре принципа ООП:
	- Инкапсуляция - принцип ООП, который заключается в объединение данных и методов, работающих с этими данными, внутри одного объекта. %%Он подразумевает ограничение прямого доступа к данным, предоставляя доступ только через определённые методы. %%
	- Полиморфизм --> способность функций или объектов обрабатывать данные разного типа и вести себя по-разному в зависимости от контекста. %%Программа во время компиляции определяет какую версию оператора или функции использовать.%% 
	- %%Полиморфизм по время компиляции(	- Перегрузка функций
		- Перегрузка операторов  )/ полиморфизм во время выполнения программы (вызывает функции во время выполнения программы) (Это через операторы virtual и override)%%
	- Наследование --> возможность порождать один класс от другого, с сохранением свойств и методов класса предка, и возможность добавить новые свойства и методы.
	- Абстракция --> принцип позволяющий скрыть детали реализации и предоставлять пользователю только функциональность необходимую для работы.



### Принцип проектирования SOLID

*SOLID --> состоит из 5-ти принципов ООП направлен на упрощение чтения, тестирования и сопровождение кода.

S %% (SRP - Signle Responsibility Principle -- принцип единственной ответственности.) %% --> говорит о том, что каждый класс , метод или другой компонент программы, должен выполнять одну конкретную задачу.
Признаки нарушения:
	- Смешивание обязанностей 
	- Длинные методы с множеством функций 
	- Частые изменения класса 

O %% (OCP - Open / closed Principle - принцип открытости / закрытости) %%--> гласит, что все программные сущности (классы, методы и т.д.) должны быть открыты для расширения, но закрыты для изменения.
Как соблюдать:
	- Использовать абстракции (пример : shape) которая не является сущностью(не существует)
	- Разделять ответственность 
	- Не бояться добавлять больше кода
	
L %% (LSP - Liskov Substitution Priciple - принцип постановки Лисков) %% --> гласит, что функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
Правила использования принципа:
	- Подкласс не должен добавлять новых условий
	- Подкласс должен сохранять "обещания" базового класса (В базовом классе есть метод "periment ()", то все наследуемые классы от базового должны возвращать именно периметр, а не что-то другое)
	- Подкласс не должен изменять логику базового класса

I %% (ISP - Interface Segregation Principle -принцип разделения интерфейса) %%  --> клиенты не должны завесить от методов, которые они не используют. // Много небольших интерфейс для разных элементов -- лучше, чем один большой интерфейс.
%%Интерфейс - класс, может быть абстрактным и нет, от которого могут наследоваться другие классы.%%

D %% (DIP- Dependency Inversion Principle - принцип инверсии зависимости) %% --> модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракции. Абстракции не должны зависеть от деталей, а детали должны зависеть об абстракции. 


### GRASP

GRASP %% (General Responsibility Assignment Software Patterns or General Responsibility Assignment Software Principle) %% --> шаблоны проектирования, используемые для решения общих задач по назначению обязанностей классам и объектам.

Information Expert (информационный эксперт) --> Ответственность за обработку данных должна быть у того объекта, который обладает все необходимой информацией. 

Преимущество его надо использовать:
	- Помогает избегать избыточных зависимостей
	- Снижает дублирование кода
	- Упрощает поддержку (гибкость / масштабируемость)
	
Нарушение принципа:
![[Pasted image 20250214095427.png]]
Правильное использование:
![[Pasted image 20250214101543.png]]

Low coupling (слабое зацепление) --> модули (классы, объекты) в программе должны иметь как можно меньше зависимостей друг от друга. 

Преимущества:
	- Классы со слабым зацеплением имеют слабую зависимость от других классов
	- Не зависят от внешних изменений
	- Просты для повторного использования

Минусы:
	- Затрудняется понимание логики модулей
	- Сложное изменение программы (модификация)
	- Невозможность переиспользование отдельного модуля 

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214103006.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214103157.png]]

Hign cohesion (высокая связанность) - каждый класс должен выполнять только одну логическую связанную задачу.

Пример нарушения принципа:
![[Pasted image 20250214104149.png]]
Правильно использование принципа:
![[Pasted image 20250214104408.png]]

![[Pasted image 20250214104537.png]]

Controller (контроллер) --> управление обработкой запросов должно выполняться отдельным классом-контроллером.
Задачи:
	- Принимает входные команды
	- Управляет бизнес-логикой
	- Вызывает нужные объекты и передаёт им данные
	- Контролирует порядок выполнения операций

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214104954.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214105409.png]]

Creator (создатель) --> объект должен создавать другие объекты, если он преимущественно их использует. ![[Pasted image 20250214105532.png]]

Помогает уменьшить кол-во зависимостей
В каком случае класс "а" должен создавать объекты "b":
	- Если a содержит b
	- Если а использует b
	- Если а знает, как инициализировать b и у него есть данные для этого
	- 

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214110120.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214110201.png]]

Pure Fabrication (числа выдумка) --> иногда полезно создавать классы, которые не отражают объекты предметной области, но помогают сделать код чище и структурированнее. 

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214120103.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214120223.png]]

Inderection (перенаправление) --> между двумя связанными компонентами можно ввести промежуточный слой, который управляет их взаимодействием.

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214120604.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214120819.png]]

Polymorphism (полиморфизм) --> Разные классы могут иметь одинаковый интерфейс и быть обработаны единообразно.

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214121253.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214121245.png]]


Protected Variations (устойчивость к изменениям) --> Определяйте точки возможных изменений и защищайте их с помощью устойчивых абстракций или механизмов инкапсуляции.

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214121644.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214121626.png]]




### Паттерны

Паттерны --> шаблон решения типичных задач, которые возникают в процессе разработки объектно-ориентированных систем.

Порождающие паттерны --> паттерны, которые абстрагируют процесс инстанцирования или, иными словами, процесс порождения классов и объектов.

Виды порождающих паттернов:
	-Фабричный метод
	-Абстрактная фабрика
	-Строитель
	-Прототип
	-Одиночка

Фабричный метод --> порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов. 

Строитель --> порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

Когда применять:
	 - Когда вы хотите избавиться от "телескопического конструктора"
	 - Когда ваш код должен создавать разные представления какого-то объекта
	 - Когда вам нужно собирать сложные составные объекты

Преимущества:
	- Позволяет создавать продукты пошагово
	- Позволяет использовать один и тот же код для создания различных продуктов
	- Изолирует сложный код сборки продукта от его основной бизнес-логики

Недостатки:
	- Усложняет код программы из-за введения доп. классов
	- Клиент будет привязан к конкретным класса строителей, т.к. в интерфейсе директора может не быть методы получения результата.



![[Pasted image 20250219095142.png]]

![[Pasted image 20250219095235.png]]

![[Pasted image 20250219095330.png]]

![[Pasted image 20250219095406.png]]

###### Паттерн --> Фабричный метод
Фабричный метод --> порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов. 

Когда применять:
	-Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать код
	-Когда вы хотите дать возможность пользователям расширять части вашего Фреймворка или библиотеки.
	-Когда хотите экономить ресурсы системы, повторно используя уже созданные объекты, вместо порождения новых.

![[Pasted image 20250221094404.png]]

Основная идея паттерна -->  
![[Pasted image 20250221094433.png]]

Виды фабричных методов --> 
![[Pasted image 20250221094447.png]]

Плюсы --> 
	- Избавляет класс от привязки к конкретным классам продуктов
	- Выделяет код производства продуктов в одно место, упрощая поддержку кода
	- Упрощает добавления новых продуктов в программу
	- Реализует принцип открытости/закрытости
![[Pasted image 20250221094514.png]]

Минусы --> 
	- Может привести к созданию больших параллельных иерархий классов, т.к. для каждого класса продукты надо создавать свой подкласс создателя
![[Pasted image 20250221094527.png]]

Вывод
![[Pasted image 20250221094541.png]]

###### Паттерн --> Абстрактная фабрика
Абстрактная фабрика --> порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
![[Pasted image 20250221101027.png]]

Когда применять:
	- Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов
	- Когда в программе уже используются фабричный метод, но очередные изменения предполагают введения новых типов продуктов.

Плюсы:
	- Гарантирует сочетаемость создаваемых продуктов
	- Избавляет клиентский код от привязки к конкретным классам продуктов
	- Выделяет код производства продуктов в одно место, упрощая поддержку кода
	- Упрощает добавление новых продуктов в программу
	- Реализует принцип открытости / закрытости

Минусы:
	- Усложняет код программы из-за введения множества  дополнительных классов
	- Требует наличия всех типов продуктов в каждой вариации

###### Паттерн --> Прототип
Прототип --> порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности реализации. 

Когда применять:
	- Когда ваш код не должен зависеть от классов копируемых объектов
	- Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создавать все эти классы, чтобы иметь возможность легко порождать объекты с определенной конфигурацией.

Плюсы:
	- Позволяет клонировать объекты, не привязываясь к их конкретным классам
	- Меньше повторяющегося кода инициализации объектов
	- Ускоряет создание объектов
	- Альтернатива созданию подклассов для конструирования сложных объектов

Минусы:
	- Сложно клонировать составные объекты, имеющие ссылки на другие объекты. 
###### Паттерн --> Одиночка
Одиночка --> порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

Когда применять:
	- Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы) 
	- Когда вам хочется иметь больше контроля над глобальными переменными

Плюсы:
	- Гарантирует наличие единственного экземпляра класса
	- Предоставляет к нему глобальную точку доступа
	- Реализует отложенную инициализацию объекта-одиночки
Минусы:
	- Нарушает принцип единственной ответственности класса
	- Маскирует плохой дизайн
	- Проблемы мультипоточности
	- Требует постоянного создания Mock-объектов при юнит-тестировании.