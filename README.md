### *ООП
ООП --> парадигма разработки ПО при которой программа представляется как совокупность объектов, взаимодействующих друг с другом.*

Свойства --> поля(атрибуты)
Действия --> методы (функции)

ООП --> Он завязан на действиях. Исходит от объектов(сущностях)

Преимущества:
	- Модульность (код разбит на модули)
	- Масштабируемость 
	- Безопасность 
	- Паттерны (шаблоны проектирования)

Недостатки:
	- Сложность освоения 
	- Снижение производительности  
	- Громоздкость кода
	- Потенциальная избыточность 

Четыре элемента ООП:
	- Объект --> это сущность, представляющая собой комбинацию свойств и методов.
	- Класс --> шаблон для создания объекта
	- Атрибут --> переменные принадлежащие объекту, то есть хранят характеристики объектов.
	- Метод --> функции, которые определяются внутри класса, и работают с его данными
		- Getter/ setter (getter --> для узнавания значений, setter --> для изменения значений)
		- Конструкторы / деструкторы

Область видимости:
	- Public --> Доступно везде
	- Protected --> Доступно только наследникам
	- Private --> Доступно только для этого класса

Четыре принципа ООП:
	- Инкапсуляция - принцип ООП, который заключается в объединение данных и методов, работающих с этими данными, внутри одного объекта. %%Он подразумевает ограничение прямого доступа к данным, предоставляя доступ только через определённые методы. %%
	- Полиморфизм --> способность функций или объектов обрабатывать данные разного типа и вести себя по-разному в зависимости от контекста. %%Программа во время компиляции определяет какую версию оператора или функции использовать.%% 
	- %%Полиморфизм по время компиляции(	- Перегрузка функций
		- Перегрузка операторов  )/ полиморфизм во время выполнения программы (вызывает функции во время выполнения программы) (Это через операторы virtual и override)%%
	- Наследование --> возможность порождать один класс от другого, с сохранением свойств и методов класса предка, и возможность добавить новые свойства и методы.
	- Абстракция --> принцип позволяющий скрыть детали реализации и предоставлять пользователю только функциональность необходимую для работы.



### Принцип проектирования SOLID

*SOLID --> состоит из 5-ти принципов ООП направлен на упрощение чтения, тестирования и сопровождение кода.

S %% (SRP - Signle Responsibility Principle -- принцип единственной ответственности.) %% --> говорит о том, что каждый класс , метод или другой компонент программы, должен выполнять одну конкретную задачу.
Признаки нарушения:
	- Смешивание обязанностей 
	- Длинные методы с множеством функций 
	- Частые изменения класса 

O %% (OCP - Open / closed Principle - принцип открытости / закрытости) %%--> гласит, что все программные сущности (классы, методы и т.д.) должны быть открыты для расширения, но закрыты для изменения.
Как соблюдать:
	- Использовать абстракции (пример : shape) которая не является сущностью(не существует)
	- Разделять ответственность 
	- Не бояться добавлять больше кода
	
L %% (LSP - Liskov Substitution Priciple - принцип постановки Лисков) %% --> гласит, что функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
Правила использования принципа:
	- Подкласс не должен добавлять новых условий
	- Подкласс должен сохранять "обещания" базового класса (В базовом классе есть метод "periment ()", то все наследуемые классы от базового должны возвращать именно периметр, а не что-то другое)
	- Подкласс не должен изменять логику базового класса

I %% (ISP - Interface Segregation Principle -принцип разделения интерфейса) %%  --> клиенты не должны завесить от методов, которые они не используют. // Много небольших интерфейс для разных элементов -- лучше, чем один большой интерфейс.
%%Интерфейс - класс, может быть абстрактным и нет, от которого могут наследоваться другие классы.%%

D %% (DIP- Dependency Inversion Principle - принцип инверсии зависимости) %% --> модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракции. Абстракции не должны зависеть от деталей, а детали должны зависеть об абстракции. 


### GRASP

GRASP %% (General Responsibility Assignment Software Patterns or General Responsibility Assignment Software Principle) %% --> шаблоны проектирования, используемые для решения общих задач по назначению обязанностей классам и объектам.

Information Expert (информационный эксперт) --> Ответственность за обработку данных должна быть у того объекта, который обладает все необходимой информацией. 

Преимущество его надо использовать:
	- Помогает избегать избыточных зависимостей
	- Снижает дублирование кода
	- Упрощает поддержку (гибкость / масштабируемость)
	
Нарушение принципа:
![[Pasted image 20250214095427.png]]
Правильное использование:
![[Pasted image 20250214101543.png]]

Low coupling (слабое зацепление) --> модули (классы, объекты) в программе должны иметь как можно меньше зависимостей друг от друга. 

Преимущества:
	- Классы со слабым зацеплением имеют слабую зависимость от других классов
	- Не зависят от внешних изменений
	- Просты для повторного использования

Минусы:
	- Затрудняется понимание логики модулей
	- Сложное изменение программы (модификация)
	- Невозможность переиспользование отдельного модуля 

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214103006.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214103157.png]]

Hign cohesion (высокая связанность) - каждый класс должен выполнять только одну логическую связанную задачу.

Пример нарушения принципа:
![[Pasted image 20250214104149.png]]
Правильно использование принципа:
![[Pasted image 20250214104408.png]]

![[Pasted image 20250214104537.png]]

Controller (контроллер) --> управление обработкой запросов должно выполняться отдельным классом-контроллером.
Задачи:
	- Принимает входные команды
	- Управляет бизнес-логикой
	- Вызывает нужные объекты и передаёт им данные
	- Контролирует порядок выполнения операций

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214104954.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214105409.png]]

Creator (создатель) --> объект должен создавать другие объекты, если он преимущественно их использует. ![[Pasted image 20250214105532.png]]

Помогает уменьшить кол-во зависимостей
В каком случае класс "а" должен создавать объекты "b":
	- Если a содержит b
	- Если а использует b
	- Если а знает, как инициализировать b и у него есть данные для этого
	- 

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214110120.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214110201.png]]

Pure Fabrication (числа выдумка) --> иногда полезно создавать классы, которые не отражают объекты предметной области, но помогают сделать код чище и структурированнее. 

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214120103.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214120223.png]]

Inderection (перенаправление) --> между двумя связанными компонентами можно ввести промежуточный слой, который управляет их взаимодействием.

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214120604.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214120819.png]]

Polymorphism (полиморфизм) --> Разные классы могут иметь одинаковый интерфейс и быть обработаны единообразно.

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214121253.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214121245.png]]


Protected Variations (устойчивость к изменениям) --> Определяйте точки возможных изменений и защищайте их с помощью устойчивых абстракций или механизмов инкапсуляции.

==Пример использования==:
	- Пример нарушения принципа:
		- ![[Pasted image 20250214121644.png]]
	- Правильное использование принципа:
		- ![[Pasted image 20250214121626.png]]























































